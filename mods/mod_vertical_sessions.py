# -*- coding: utf-8 -*-

"""
/***************************************************************************
 VerticalSessions
                                 A QGIS plugin
 Used to Vertical Sessions of Lidar Point Cloud
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-05
        copyright            : (C) 2022 by Consultoria/ Topocart
        email                : contato@topocart.com.br
        git sha              : $Format:%H$
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
 This script initializes the plugin, making it known to QGIS.
"""

import math
import os
import json
from datetime import datetime as dt
from PyQt5.QtCore import QPoint, QThread, pyqtSignal, QRegExp, QVariant
from PyQt5.QtGui import QPainter, QPen, QRegExpValidator
from PyQt5.QtWidgets import QRadioButton, QButtonGroup, QHBoxLayout, QSpinBox
from qgis.PyQt.QtCore import QSettings, Qt, QSize, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QCursor, QPixmap, QIcon, QColor, QFont
from qgis.PyQt.QtWidgets import (QAction, QScrollArea, QFileDialog, QGridLayout, QPushButton, QComboBox, QLabel,
                                 QCheckBox, QLineEdit, QFrame, QWidget, QSizePolicy, QSpacerItem, QDockWidget, QSplitter)
from qgis.PyQt import QtCore
from qgis.core import (QgsPointXY, QgsPointCloudLayer, QgsFields, QgsField, QgsFeature, QgsPoint,
                       QgsGeometry, QgsProject, QgsWkbTypes, QgsDataSourceUri, QgsVectorLayer, QgsMapLayerProxyModel)
from qgis.gui import QgsMapToolIdentify, QgsRubberBand, QgsMapLayerComboBox, QgsAdvancedDigitizingDockWidget


from .mod_aux_tools import AuxTools

plugin_path = os.path.dirname(os.path.dirname(__file__))
# sys.path.append(os.path.join(os.path.join(plugin_path, 'libs')))


class VerticalSessions:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.name_ = 'Vertical Sessions'
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            plugin_path,
            'i18n',
            '{}_{}.qm'.format(self.name_.replace(' ',''), locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes

        self.actions = []
        self.menu = self.tr(f'&T {self.name_}')
        self.dic_prj_conn = {}
        self.dic_icon = {}

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate(self.name_.replace(' ',''), message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon()
        icon.addPixmap(QPixmap(icon_path))
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        print('initGui')
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # self.dock = QDockWidget('T - Inventário de Via.')

        self.dock = QgsAdvancedDigitizingDockWidget(self.iface.mapCanvas())
        self.dock.setWindowTitle(f'T - {self.name_}.')

        self.inv_wd = WdVS(self.iface, parent=self.dock, main=self)
        # self.inv_wd.setMinimumHeight(50)
        self.inv_wd.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.dock.setWidget(self.inv_wd)
        self.dock.setObjectName(f"{self.name_} Panel")
        self.dock.setMinimumHeight(60)
        # self.dock.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # self.dock.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)

        # self.dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.LeftDockWidgetArea)
        self.iface.addDockWidget(Qt.BottomDockWidgetArea, self.dock)
        icon_path = os.path.join(plugin_path, 'icons/icon_vs.png')
        # icon_ = QIcon()
        # icon_.addPixmap(QPixmap(icon_path))
        # self.dock.setWindowIcon(icon_)
        self.add_action(
            icon_path,
            text=self.tr(''),
            callback=self.call_vs,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        print('unload')
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(f'T - {self.name_}.'),
                action)
            self.iface.removeToolBarIcon(action)
        for x in self.iface.mainWindow().findChildren(QDockWidget):
            if x.objectName() == f"{self.name_} Panel":
                # print(x.objectName())
                del x

    def call_vs(self):
        if not self.dock.isVisible():
            self.dock.setVisible(True)
        # self.inv_wd.get_inv()

    def plugin_version(self):
        meta_file = plugin_path + "/metadata.txt"
        # print(meta_file)
        with open(meta_file) as meta:
            mt = meta.readlines()
            for l_ in mt:
                if l_[:8] == "version=":
                    # print('cur_version=', l_[8:].replace('\n', ''))
                    return l_[8:].replace('\n', '')
        return '0.0'


class WdVS(QWidget):
    def __init__(self, iface, parent=None, main=None):
        super(WdVS, self).__init__(parent)

        self.filter_dlg = None
        self.setObjectName('WdVS')
        # Save reference to the QGIS interface
        self.iface = iface
        self.parent = parent
        self.main = main
        if os.getlogin() == 'adriano.caliman' or os.getlogin() == 'issac.antunes':
            self.iface.actionShowPythonDialog().trigger()
        self.dic_layers_tools = {
            'fp': {},
            'fp_stats': {},
            }
        self.config_rubber_bands()
        self.canvas = self.iface.mapCanvas()
        self.list_anim = []
        self.aux_tools = AuxTools(parent=self)

        self.dic_current_cell = {'row': 0, 'color': None}

        lg = self.create_layout()
        self.setLayout(lg)

        self.cloud_thread = None
        self.cloud_node_group = None
        self.w_ = 2
        self.z_ = None
        self.cloud_layer_catalog = None

    def create_layout(self):
        gl_prof = QGridLayout()
        gl_prof.setContentsMargins(0, 0, 0, 0)
        gl_prof.setSpacing(1)
        spt_left = QSplitter(Qt.Horizontal)
        # gl_.addWidget(spt_left, 1, 0)
        gl_prof.addWidget(spt_left, 0, 0)

        wd_tool = QWidget()
        sp_ = QSizePolicy()
        sp_.setHorizontalPolicy(QSizePolicy.Minimum)
        sp_.setHorizontalStretch(0)
        sp_.setVerticalPolicy(QSizePolicy.Expanding)
        wd_tool.setSizePolicy(sp_)
        gl_tool = QGridLayout()
        gl_tool.setContentsMargins(0, 0, 0, 0)
        wd_tool.setLayout(gl_tool)
        spt_left.addWidget(wd_tool)

        self.lb_session_logo = QLabel()
        self.lb_session_logo.setFixedSize(QSize(20, 20))
        pixmap_ = QPixmap(os.path.join(plugin_path, 'icons/icon_session.png'))
        scaled_ = pixmap_.scaled(self.lb_session_logo.size(), QtCore.Qt.KeepAspectRatio)
        self.lb_session_logo.setPixmap(scaled_)
        r_ = 0
        gl_tool.addWidget(self.lb_session_logo, r_, 0)

        self.lb_topo_logo = QLabel()
        self.lb_topo_logo.setFixedSize(QSize(70, 30))
        pixmap_ = QPixmap(os.path.join(plugin_path, 'icons/topo_logo.png'))
        scaled_ = pixmap_.scaled(self.lb_topo_logo.size(), QtCore.Qt.KeepAspectRatio)
        self.lb_topo_logo.setPixmap(scaled_)
        gl_tool.addWidget(self.lb_topo_logo, r_, 1)

        gl_tool.addItem(QSpacerItem(0, 0, QSizePolicy.Expanding, QSizePolicy.Minimum), r_, 2)

        self.lb_version = QLabel(f'v{self.main.plugin_version()}')
        self.lb_version.setAlignment(Qt.AlignRight)
        gl_tool.addWidget(self.lb_version, r_, 3)

        self.pb_def_fp = QPushButton('Set Session Footprint')
        self.pb_def_fp.setIcon(QIcon(os.path.join(plugin_path, f'icons/icon_session_fp.png')))
        r_ += 1
        gl_tool.addWidget(self.pb_def_fp, r_, 0, 1, 4)

        self.chk_hand_width = QCheckBox('Fixed Width:')
        self.chk_hand_width.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        r_ += 1
        gl_tool.addWidget(self.chk_hand_width, r_, 1)

        self.le_hand_width = QLineEdit()
        self.le_hand_width.setEnabled(False)
        self.le_hand_width.setText('0.1')
        self.le_hand_width.setMaximumWidth(50)
        self.le_hand_width.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        validator = QRegExpValidator(QRegExp(r'[0-9].+'))
        self.le_hand_width.setValidator(validator)
        gl_tool.addWidget(self.le_hand_width, r_, 2, 1, 2)

        self.chk_hand_length = QCheckBox('Fixed Length:')
        self.chk_hand_length.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        r_ += 1
        gl_tool.addWidget(self.chk_hand_length, r_, 1)

        self.le_hand_length = QLineEdit()
        self.le_hand_length.setEnabled(False)
        self.le_hand_length.setText('10.0')
        self.le_hand_length.setMaximumWidth(50)
        self.le_hand_length.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        validator = QRegExpValidator(QRegExp(r'[0-9].+'))
        self.le_hand_length.setValidator(validator)
        gl_tool.addWidget(self.le_hand_length, r_, 2, 1, 2)

        f_ = QFrame()
        f_.setFrameShape(QFrame.HLine)
        r_ += 1
        gl_tool.addWidget(f_, r_, 1, 1, 3)

        self.btn_group = QButtonGroup()
        self.pb_previous = QPushButton()
        self.btn_group.addButton(self.pb_previous,id=-10)
        self.pb_previous.setIcon(QIcon(os.path.join(plugin_path, f'icons/icon_previous.png')))
        self.pb_previous.setToolTip('Previous/ Left Session')
        self.pb_previous.setMaximumWidth(50)
        r_ += 1
        gl_tool.addWidget(self.pb_previous, r_, 1, 1, 1)

        self.pb_next = QPushButton()
        self.btn_group.addButton(self.pb_next, id=10)
        self.pb_next.setIcon(QIcon(os.path.join(plugin_path, f'icons/icon_next.png')))
        self.pb_next.setToolTip('Next/ Right Session')
        self.pb_next.setMaximumWidth(50)
        # r_ += 1
        gl_tool.addWidget(self.pb_next, r_, 2, 1, 2)

        self.lb_interval = QLabel('Interval:')
        self.lb_interval.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        r_ += 1
        gl_tool.addWidget(self.lb_interval, r_, 1)

        self.le_interval = QLineEdit()
        self.le_interval.setEnabled(True)
        self.le_interval.setText('10.0')
        self.le_interval.setMaximumWidth(50)
        self.le_interval.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        validator = QRegExpValidator(QRegExp(r'[0-9].+'))
        self.le_interval.setValidator(validator)
        gl_tool.addWidget(self.le_interval, r_, 2, 1, 2)

        f_ = QFrame()
        f_.setFrameShape(QFrame.HLine)
        r_ += 1
        gl_tool.addWidget(f_, r_, 1, 1, 3)

        self.chk_follow_line = QCheckBox('Follow Alignment:')
        self.chk_follow_line.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        r_ += 1
        gl_tool.addWidget(self.chk_follow_line, r_, 1)

        r_ += 1
        lb_ = QLabel('Layer:')
        gl_tool.addWidget(lb_, r_, 1, 1, 1)
        self.mlcb_layer = QgsMapLayerComboBox(self)
        self.mlcb_layer.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.mlcb_layer.setEnabled(False)
        self.mlcb_layer.setToolTip('It need be a line Layer')
        gl_tool.addWidget(self.mlcb_layer, r_, 1, 1, 3)

        self.pb_get_feature = QPushButton('Select Feature')
        self.pb_get_feature.setIcon(QIcon(os.path.join(plugin_path, f'icons/icon_axis.png')))
        self.pb_get_feature.setEnabled(False)
        r_ += 1
        gl_tool.addWidget(self.pb_get_feature, r_, 1, 1, 2)

        r_ += 1
        gl_tool.addItem(QSpacerItem(10, 10, QSizePolicy.Minimum, QSizePolicy.Expanding), r_, 0)

        wd_layer= QWidget()
        gl_layer= QGridLayout()
        gl_layer.setContentsMargins(0, 0, 0, 0)
        wd_layer.setLayout(gl_layer)
        spt_left.addWidget(wd_layer)

        lh_ = QHBoxLayout()
        lh_.addWidget(QLabel('Point Size:'))
        self.spb_point_size = QSpinBox()
        self.spb_point_size.setValue(3)
        self.spb_point_size.setMaximumWidth(45)
        lh_.addWidget(self.spb_point_size)
        rr_ = 0
        gl_layer.addLayout(lh_, rr_, 1, 1, 2)

        rr_ += 1
        gl_layer.addWidget(QLabel('Symbology:'), rr_, 1, 1, 2)
        gen_group = QButtonGroup(self)
        self.rb_symb_canvas = QRadioButton('Like Canvas')
        self.rb_symb_canvas.setChecked(True)
        gen_group.addButton(self.rb_symb_canvas)
        rr_ += 1
        gl_layer.addWidget(self.rb_symb_canvas, rr_, 1, 1, 2)

        self.rb_symb_pers = QRadioButton('Personalized')
        gen_group.addButton(self.rb_symb_pers)
        rr_ += 1
        gl_layer.addWidget(self.rb_symb_pers, rr_, 1, 1, 2)

        self.cmb_pers_symb = QComboBox()
        self.cmb_pers_symb.setEnabled(False)
        self.cmb_pers_symb.addItems(['Intensity', 'RGB', 'CLASS', 'Elevation', 'Point Source ID', 'PSID + Intensity'])
        rr_ += 1
        gl_layer.addWidget(self.cmb_pers_symb, rr_, 1)

        rr_ += 1
        gl_layer.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding), rr_, 0)

        rr_ += 1
        gl_layer.addWidget(QLabel('Density (ppm):'), rr_, 1, 1, 2)

        lh_ = QHBoxLayout()
        self.le_max_dens = QLineEdit()
        self.le_max_dens.setEnabled(False)
        self.le_max_dens.setText('10.0')
        lh_.addWidget(self.le_max_dens)
        self.pb_set_dens = QPushButton('Get')
        self.pb_set_dens.setIcon(QIcon(os.path.join(plugin_path, f'icons/icon_session_stats.png')))
        self.pb_set_dens.setMaximumWidth(45)
        lh_.addWidget(self.pb_set_dens)
        rr_ += 1
        gl_layer.addLayout(lh_, rr_, 1, 1, 2)

        f_ = QFrame()
        f_.setFrameShape(QFrame.VLine)
        rr_ += 1
        gl_layer.addWidget(f_, 0, 0, rr_, 1)

        wd_view = QWidget()
        sp_ = QSizePolicy()
        sp_.setHorizontalPolicy(QSizePolicy.Expanding)
        sp_.setHorizontalStretch(255)
        sp_.setVerticalPolicy(QSizePolicy.Expanding)
        wd_view.setSizePolicy(sp_)
        gl_view = QGridLayout()
        gl_view.setContentsMargins(0, 0, 0, 0)
        wd_view.setLayout(gl_view)
        spt_left.addWidget(wd_view)

        f_ = QFrame()
        f_.setFrameShape(QFrame.VLine)
        gl_view.addWidget(f_, 0, 0, 2, 1)

        self.wdl_prof = ProfileView(self, 'Rec. Prof.')
        self.wdl_prof.resize(300, 150)
        self.wdl_prof.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        gl_view.addWidget(self.wdl_prof, 0, 1)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setLayout(gl_prof)
        lg_sa = QGridLayout()
        lg_sa.setContentsMargins(0, 0, 0, 0)
        lg_sa.setSpacing(0)
        lg_sa.addWidget(scroll_area)

        self.trigger_actions()
        return lg_sa

    def trigger_actions(self):

        # self.action_pass.triggered.connect(self.toggle_visibility)
        # QgsProject.instance().homePathChanged.connect(self.check_proj)
        # # self.gvw_360.mouseDoubleClickEvent = self.show_picture
        # for tag_ in self.dic_player:
        #     self.dic_player[tag_].clicked.connect(partial(self.player, tag_))
        #
        # self.cmb_dom_grp_inv.currentIndexChanged.connect(self.fill_twd_att)
        # self.chk_show_cloud.toggled.connect(self.show_cloud)
        # self.pb_new_2d.clicked.connect(self.get_2d_point)
        # self.pb_add_cloud.clicked.connect(self.add_cloud)
        self.btn_group.buttonClicked[int].connect(self.move_fp)
        self.pb_def_fp.clicked.connect(self.get_fp)
        self.chk_hand_width.toggled.connect(lambda is_chk: self.le_hand_width.setEnabled(is_chk))
        self.chk_hand_length.toggled.connect(lambda is_chk: self.le_hand_length.setEnabled(is_chk))
        self.chk_follow_line.toggled.connect(self.enable_follow_line)
        self.spb_point_size.valueChanged.connect(self.update_session_painter)
        self.pb_set_dens.clicked.connect(self.get_max_dens_fp)
        QgsProject.instance().layersAdded.connect(self.layer_added)
        QgsProject.instance().layersRemoved.connect(self.layer_removed)
        # self.mlcb_point.layerChanged.connect(self.add_vrt)
        #
        # self.pb_filter_front.clicked.connect(partial(self.nav_filter, '>'))
        # self.pb_filter_back.clicked.connect(partial(self.nav_filter, '<'))
        # self.pb_filter_set.clicked.connect(self.filter_settings)
        # self.pb_filter_list.clicked.connect(self.calc_step)

    def config_rubber_bands(self):

        rb_ = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.LineGeometry)
        rb_.setColor(QColor(0, 0, 255, 90))
        rb_.setLineStyle(Qt.DotLine)
        rb_.setWidth(5)
        self.dic_layers_tools['track'] = {'rb': rb_}

        rb_ = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.PolygonGeometry)
        rb_.setWidth(2)
        rb_.setColor(QColor(0, 255, 255, 50))
        color_ = QColor(Qt.lightGray)
        color_.setAlpha(90)
        rb_.setFillColor(color_)
        self.dic_layers_tools['rec'] = {'rb': rb_}

        rb_ = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.LineGeometry)
        rb_.setColor(Qt.green)
        rb_.setLineStyle(Qt.DashLine)
        rb_.setWidth(2)
        self.dic_layers_tools['line'] = {'rb': rb_}

    def get_fp(self):
        print('get_fp')
        if 'maptool' not in self.dic_layers_tools['fp']:
            mt_ = SelectFootPrint(self.iface, parent=self)
            self.dic_layers_tools['fp']['maptool'] = mt_
        else:
            mt_ = self.dic_layers_tools['fp']['maptool']
        self.iface.mapCanvas().setMapTool(mt_)

    def select_fp(self, dic_):
        print('select_fp')
        if 'line' in dic_:
            self.dic_layers_tools['line']['rb'].reset()
            self.dic_layers_tools['line']['rb'].setToGeometry(dic_['line'])
        if 'rec' in dic_:
            self.dic_layers_tools['rec']['rb'].reset()
            self.dic_layers_tools['rec']['rb'].setToGeometry(dic_['rec'])
        if 'identify' in dic_:
            stats_ = True if dic_['identify'] == 'stats' else False
            self.identify_cloud(stats=stats_)
        if 'reset' in dic_:
            self.dic_layers_tools['rec']['rb'].reset()
            self.dic_layers_tools['line']['rb'].reset()
            self.dic_layers_tools['track']['rb'].reset()
            self.wdl_prof.p_track = None
            self.wdl_prof.update()

    def get_max_dens_fp(self):
        print('get_fp')
        if 'maptool' not in self.dic_layers_tools['fp_stats']:
            mt_ = SelectFootPrint(self.iface, parent=self, stats=True)
            self.dic_layers_tools['fp_stats']['maptool'] = mt_
        else:
            mt_ = self.dic_layers_tools['fp_stats']['maptool']
        self.iface.mapCanvas().setMapTool(mt_)

    def move_fp(self, bt_):
        print('move_fp', bt_)
        geom_ = self.dic_layers_tools['line']['rb'].asGeometry()
        stt_point = QgsPoint(geom_.asPolyline()[0])
        end_point = QgsPoint(geom_.asPolyline()[-1])
        az_ = stt_point.azimuth(end_point)
        i_ = float(self.le_interval.text())
        p1 = calc_proj(stt_point, (90 * bt_/10) + az_, i_)
        p2 = calc_proj(end_point, (90 * bt_/10) + az_, i_)
        line_ = QgsGeometry().fromPolylineXY([p1, p2])
        d_ = float(self.le_hand_width.text())
        pr1 = calc_proj(p1, az_ - 90, d_)
        pr2 = calc_proj(p2, az_ - 90, d_)
        pr3 = calc_proj(p2, az_ + 90, d_)
        pr4 = calc_proj(p1, az_ + 90, d_)
        pol_ = QgsGeometry.fromPolygonXY([[pr1, pr2, pr3, pr4,]])
        self.select_fp({'line': line_, 'rec': pol_, 'identify': True})

    def enable_follow_line(self, is_chk):
        # self.le_hand_width.setEnabled(is_chk)
        self.mlcb_layer.setEnabled(is_chk)
        self.pb_get_feature.setEnabled(is_chk)

    def identify_cloud(self, stats=False):
        print('identify_cloud')
        list_rll = []

        pol_ = self.dic_layers_tools['rec']['rb'].asGeometry()
        list_ = pol_.asMultiPolygon()[0][0]
        lg_1 = QgsGeometry().fromPolyline([QgsPoint(list_[3]), QgsPoint(list_[0])])
        lg_2 = QgsGeometry().fromPolyline([QgsPoint(list_[3]), QgsPoint(list_[2])])
        list_rll.append([0, lg_1, lg_2])
        dic_ = {'rec': pol_, 'rll': list_rll}

        if not self.cloud_layer_catalog:
            self.vrt_cl_catalog()
        list_layer = []
        for feat_ in self.cloud_layer_catalog.getFeatures():
            if feat_.geometry().intersects(pol_):
                layer_name = feat_['nome_layer']
                list_layer.append(QgsProject.instance().mapLayersByName(layer_name)[0])

        if self.cloud_thread:
            self.cloud_thread.stop = True
        self.cloud_thread = CloudThread(main=self.main, parent=self, dic_=dic_, list_layer=list_layer, stats=stats)
        self.cloud_thread.start()

    def vrt_cl_catalog(self):
        print('vrt_cl_catalog')
        ls_ = QgsProject.instance().mapLayers()
        canva_crs = QgsProject.instance().crs().authid()
        self.cloud_layer_catalog = QgsVectorLayer('Polygon?crs={}&index=yes'.format(canva_crs), 'SV_clouds_tiles', "memory")
        fields_catalog = QgsFields()
        fields_catalog.append(QgsField('nome_layer', QVariant.String))
        pr_ = self.cloud_layer_catalog.dataProvider()
        pr_.addAttributes(fields_catalog)
        self.cloud_layer_catalog.updateFields()

        for ln_ in ls_:
            layer_ = ls_[ln_]
            if layer_.type() == 6:
                rec_ = layer_.extent()
                print('rec_ =', rec_)
                geom_ = QgsGeometry().fromRect(rec_)
                feat_ = QgsFeature()
                feat_.setGeometry(geom_)
                feat_.setAttributes([layer_.name()])
                pr_.addFeatures([feat_])
                self.cloud_layer_catalog.updateExtents()

        style_path = os.path.join(plugin_path, 'styles', f'sv_clouds_tiles.qml')
        self.cloud_layer_catalog.loadNamedStyle(style_path)
        QgsProject.instance().addMapLayer(self.cloud_layer_catalog, False)
        self.cloud_node_group = QgsProject.instance().layerTreeRoot().findGroup('__CLOUD__')
        if not self.cloud_node_group:
            self.cloud_node_group = QgsProject.instance().layerTreeRoot().insertGroup(0, '__CLOUD__')
        self.cloud_node_group.addLayer(self.cloud_layer_catalog)
        # QgsProject.instance().layerTreeRoot().findLayer(self.cloud_layer_catalog).setItemVisibilityChecked(False)
        return

    def layer_added(self, slot_):
        if self.cloud_layer_catalog:
            pr_ = self.cloud_layer_catalog.dataProvider()
            self.cloud_layer_catalog.startEditing()
            for layer_ in slot_:
                if layer_.type() == 6:
                    rec_ = layer_.extent()
                    geom_ = QgsGeometry().fromRect(rec_)
                    feat_ = QgsFeature()
                    feat_.setGeometry(geom_)
                    feat_.setAttributes([layer_.name()])
                    pr_.addFeatures([feat_])
                    self.cloud_layer_catalog.updateExtents()
            self.cloud_layer_catalog.commitChanges()
            self.cloud_layer_catalog.triggerRepaint()

    def layer_removed(self, slot_):
        print('layer_removed', slot_)
        if self.cloud_layer_catalog:
            self.cloud_layer_catalog.startEditing()
            for layer_ in slot_:
                for feat_cat in self.cloud_layer_catalog.getFeatures():
                    print(feat_cat['nome_layer'], layer_[:len(feat_cat['nome_layer'])])
                    if feat_cat['nome_layer'].replace('-', '_') == layer_[:len(feat_cat['nome_layer'])]:
                        self.cloud_layer_catalog.deleteFeature(feat_cat.id())
                        break
                self.cloud_layer_catalog.updateExtents()
            self.cloud_layer_catalog.commitChanges()
            self.cloud_layer_catalog.triggerRepaint()

    # def add_vrt(self, slot_):
    #     # print('add_vrt', slot_, self.mlcb_point.additionalItems())
    #     if not slot_:
    #         i = 1
    #         while QgsProject.instance().mapLayersByName(f'IV_Pontos_{i}'):
    #             i += 1
    #         layer_name = f'IV_Pontos_{i}'
    #         canva_crs = QgsProject.instance().crs().authid()
    #         layer_ = QgsVectorLayer('Point?crs={}&index=yes'.format(canva_crs),layer_name, "memory")
    #         fields_catalog = QgsFields()
    #         fields_catalog.append(QgsField('time', QVariant.Time))
    #         pr_ = layer_.dataProvider()
    #         pr_.addAttributes(fields_catalog)
    #         layer_.updateFields()
    #         style_path = os.path.join(plugin_path, 'styles', f'iv_pontos.qml')
    #         layer_.loadNamedStyle(style_path)
    #         QgsProject.instance().addMapLayer(layer_, False)
    #         self.cloud_node_group = QgsProject.instance().layerTreeRoot().findGroup('T__CLOUD__')
    #         if not self.cloud_node_group:
    #             self.cloud_node_group = QgsProject.instance().layerTreeRoot().insertGroup(0, '__CLOUD__')
    #         self.cloud_node_group.addLayer(layer_)
    #         self.mlcb_point.setLayer(layer_)
    #         return

    # def get_cloud_layers(self, result_):
    #     list_ = []
    #     self.cloud_node_group = QgsProject.instance().layerTreeRoot().findGroup('TOPO__CLOUD__')
    #     if not self.cloud_node_group:
    #         self.cloud_node_group = QgsProject.instance().layerTreeRoot().insertGroup(0, 'TOPO__CLOUD__')
    #
    #     for row_ in result_:
    #         path_ = row_[0]
    #         layer_name = os.path.basename(r'{}'.format(path_))[:-4]
    #         if QgsProject.instance().mapLayersByName(layer_name):
    #             list_.append(QgsProject.instance().mapLayersByName(layer_name)[0])
    #         else:
    #             layer_ = QgsPointCloudLayer(path_, layer_name, 'pdal')
    #             # crs = layer_.crs()
    #             # crs.createFromId(QgsProject.instance().crs().authid()[5:])
    #             layer_.setCrs(QgsProject.instance().crs())
    #             QgsProject.instance().addMapLayer(layer_, False)
    #             self.cloud_node_group.addLayer(layer_)
    #             list_.append(layer_)
    #     return list_

    # def add_cloud(self):
    #     print('add_cloud')
    #     if not self.db:
    #         return
    #     self.cloud_node_group = QgsProject.instance().layerTreeRoot().findGroup('TOPO__CLOUD__')
    #     if not self.cloud_node_group:
    #         self.cloud_node_group = QgsProject.instance().layerTreeRoot().insertGroup(0, 'TOPO__CLOUD__')
    #     conn_name = self.cb_db.currentText()
    #     host_ = self.dic_dbs[conn_name]['conn']['host']['value']
    #     port_ = self.dic_dbs[conn_name]['conn']['port']['value']
    #     db_ = self.dic_dbs[conn_name]['conn']['db']['value']
    #     user_ = self.dic_dbs[conn_name]['conn']['user']['value']
    #     pass_ = self.dic_dbs[conn_name]['conn']['pass']['value']
    #     sch_art = self.dic_dbs[conn_name]['sch_art']['alias'][0]
    #     tab_art = self.dic_dbs[conn_name]['sch_art']['tab']['alias'][0]
    #     fld_art_path = self.dic_dbs[conn_name]['sch_art']['fields']['fld_art_path']['alias'][0]
    #     fld_art_name = self.dic_dbs[conn_name]['sch_art']['fields']['fld_art_name']['alias'][0]
    #     if not QgsProject.instance().mapLayersByName(f'IV_{tab_art}'):
    #         uri = QgsDataSourceUri()
    #         uri.setConnection(host_, port_, db_, user_, pass_)
    #         uri.setDataSource(sch_art, tab_art, 'geom')
    #         layer_ = QgsVectorLayer(uri.uri(False), f'IV_{tab_art}', "postgres")
    #         style_path = os.path.join(self.main.plugin_dir, 'styles', f'iv_articulacao_clouds.qml')
    #         layer_.loadNamedStyle(style_path)
    #         QgsProject.instance().addMapLayer(layer_, False)
    #         self.cloud_node_group.addLayer(layer_)
    #
    #     source_ = QFileDialog.getOpenFileNames(self)
    #     if source_:
    #
    #         canva_crs = QgsProject.instance().crs().authid()[5:]
    #
    #         for path_ in source_[0]:
    #             if os.path.exists(path_):
    #                 layer_name = os.path.basename(r'{}'.format(path_))[:-4]
    #                 layer_ = QgsPointCloudLayer(path_, layer_name, 'pdal')
    #                 # layer_.asWktPolygon()
    #                 # geom_ = QgsGeometry().fromRect(layer_.extent())
    #                 str_query = f"""
    #                     INSERT INTO {sch_art}.{tab_art} (geom, {fld_art_path}, {fld_art_name})
    #                         SELECT
    #                             ST_Transform(ST_GeomFromText(\'{layer_.extent().asWktPolygon()}\', {canva_crs}), 4326) geom,
    #                             \'{path_}\' {fld_art_path} ,
    #                             \'{layer_name}\' {fld_art_name}
    #                             WHERE
    #                                 NOT EXISTS (
    #                                     SELECT 1 FROM {sch_art}.{tab_art} WHERE \"{fld_art_name}\" = \'{layer_name}\')
    #                         RETURNING id
    #                     """
    #                 # print(str_query)
    #                 result_ = self.db.select_(str_query)
    #                 if result_:
    #                     self.db.commit_()
    #                 else:
    #                     # print('já existe')
    #                     str_query = f"""
    #                         WITH t as (SELECT ST_Transform(ST_GeomFromText(\'{layer_.extent().asWktPolygon()}\', {canva_crs}), 4326) t_geom)
    #                         UPDATE {sch_art}.{tab_art} a
    #                             SET
    #                                 geom = t_geom
    #                             FROM t
    #                             WHERE
    #                                 {fld_art_name} = \'{layer_name}\' and
    #                                 not ST_Equals(geom, t_geom);
    #                         UPDATE {sch_art}.{tab_art} a
    #                             SET
    #                                 {fld_art_path} = \'{path_}\'
    #                             WHERE
    #                                 {fld_art_name} = \'{layer_name}\' and
    #                                 {fld_art_path} <> \'{path_}\';
    #                         """
    #                     self.db.query_(str_query)


    def set_track_rb(self, lt_=None):
        self.dic_layers_tools['track']['rb'].reset()
        if lt_:
            self.dic_layers_tools['track']['rb'].setToGeometry(lt_)

    def update_session_painter(self, v_=None):
        print('update_session_paint', v_)
        if self.wdl_prof:
            self.wdl_prof.update()
    #
    # def rejected(self):
    #     print('rejected')
    #     if self.map_tool_lot:
    #         self.iface.mapCanvas().unsetMapTool(self.map_tool_lot)
    #     if self.map_tool_pan:
    #         self.iface.mapCanvas().unsetMapTool(self.map_tool_pan)
    #     try:
    #         self.rejected.disconnect(self.reject)
    #     except:
    #         pass
    #     self.close_conn()


class SelectFootPrint(QgsMapToolIdentify):
    """ Select Photo on map """

    def __init__(self, iface, parent=None, stats=None):
        QgsMapToolIdentify.__init__(self, iface.mapCanvas())
        self.canvas = iface.mapCanvas()
        self.iface = iface
        self.parent = parent
        self.cursor = QCursor(QPixmap(["16 16 3 1",
                                       "      c None",
                                       ".     c #FF0000",
                                       "+     c #FFFFFF",
                                       "                ",
                                       "+               ",
                                       "+               ",
                                       "+          ..   ",
                                       "+         .  ...",
                                       "+         .     ",
                                       "+         .     ",
                                       "+        .      ",
                                       "+       .       ",
                                       "+     ..        ",
                                       "+   ..          ",
                                       "+  .            ",
                                       "+ .             ",
                                       "+.              ",
                                       "+               ",
                                       "++++++++++++++++"]))
        self.p1 = None
        self.p2 = None
        self.p3 = None
        self.stats = stats

    def activate(self):
        self.canvas.setCursor(self.cursor)

    def canvasPressEvent(self, evt_):
        print('canvasPressEvent')
        if not self.p1:
            print('set p1')
            self.parent.select_fp({'reset': True})
            self.p1 = self.toMapCoordinates(evt_.pos())
            if self.stats:
                self.geom_r = self.buffer_point()
                self.parent.select_fp({'rec': self.geom_r, 'identify': 'stats'})
                self.p1 = None

        elif self.p3:
            print('reset')
            self.parent.select_fp({'reset': True})
            self.p1 = self.toMapCoordinates(evt_.pos())
            self.p2 = None
            self.p3 = None

    def canvasMoveEvent(self, evt_):
        # print('canvasMoveEvent')
        if self.p3:
            pass
        elif self.p2:
            d_ = self.geom_l.distance(QgsGeometry(QgsPoint(self.toMapCoordinates(evt_.pos()))))
            # self.geom_r = self.geom_l.buffer(d_, -1)
            self.geom_r = self.buffer_line(d_)
            self.parent.select_fp({'rec': self.geom_r})
        elif self.p1:
            self.geom_l = QgsGeometry().fromPolylineXY([self.p1, self.toMapCoordinates(evt_.pos())])
            self.parent.select_fp({'line':self.geom_l})

    def canvasReleaseEvent(self, evt_):
        print('canvasReleaseEvent', self.stats)
        if self.p2 and not self.parent.chk_hand_width.isChecked():
            print('set p3')
            self.p3 = self.toMapCoordinates(evt_.pos())
            w_ = self.geom_l.distance(QgsGeometry(QgsPoint(self.p3)))
            self.parent.le_hand_width.setText(f'{w_:0.1f}')
            # self.geom_r = self.geom_l.buffer(d_, -1)
            self.geom_r = self.buffer_line(w_)
            # self.geom_r = self.geom_l.buffer(d_, 5, QgsGeometry.CapFlat)
            self.parent.select_fp({'rec': self.geom_r, 'identify': True})
        elif self.p1 and self.toMapCoordinates(evt_.pos()) != self.p1:
            print('set p2')
            self.p2 = self.toMapCoordinates(evt_.pos())
            if self.parent.chk_hand_length.isChecked() and self.parent.le_hand_length.text():
                l_ = float(self.parent.le_hand_length.text())
                az_ = self.p1.azimuth(self.p2)
                self.p2 = calc_proj(self.p1, az_, l_)
            else:
                l_ = self.p1.distance(self.p2)
                self.parent.le_hand_length.setText(f'{l_:0.1f}')
            self.geom_l = QgsGeometry().fromPolylineXY([self.p1, self.p2])
            self.parent.select_fp({'line': self.geom_l})
            if self.parent.chk_hand_width.isChecked():
                w_ = float(self.parent.le_hand_width.text())
                self.geom_r = self.buffer_line(w_)
                self.parent.select_fp({'rec': self.geom_r, 'identify': True})
                self.p3 = True

        # self.parent.select_fp(self.pointXY)

    def buffer_line(self, d_):
        az_ = self.p1.azimuth(self.p2)
        return QgsGeometry.fromPolygonXY([[
            calc_proj(self.p1, az_ - 90, d_),
            calc_proj(self.p2, az_ - 90, d_),
            calc_proj(self.p2, az_ + 90, d_),
            calc_proj(self.p1, az_ + 90, d_),
            # calc_proj(self.p1, az_ - 90),
        ]])

    def buffer_point(self, az_=0, d_=1):
        p1_ = calc_proj(self.p1, az_ + 45, d_ / 2 * (2 ** 0.5))
        p2_ = calc_proj(p1_, az_ + 180 , d_)
        p3_ = calc_proj(p2_, az_ - 90, d_)
        p4_ = calc_proj(p3_, az_, d_)
        return QgsGeometry.fromPolygonXY([[p1_, p2_, p3_, p4_,]])


class ProfileView(QWidget):
    def __init__(self, parent, type=None):
        super().__init__(parent)
        self.parent = parent
        self.type = type
        self.mp_ = None
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setStyleSheet('background-color: lightgray;')
        self.setMouseTracking(True)
        self.x_value = 0
        self.y_value = 999999
        self.p1 = None
        self.p2 = None
        self.fps = 18
        self.list_spiral = []
        self.dic_t = {}
        self.dic_d = {}
        self.dic_c = {}
        self.p_track = None

    def paintEvent(self, paint_event):
        print('paintEvent', dt.now())
        painter = QPainter(self)

        pen = QPen()
        ps_ = int(self.parent.spb_point_size.value())
        pen.setWidth(ps_)

        font_ = QFont()
        font_.setPixelSize(self.fps)
        painter.setFont(font_)

        painter.setRenderHint(QPainter.Antialiasing, True)
        if self.dic_t:
            for coord_ in self.dic_d:
                if not self.dic_d:
                    break
                for dep_ in self.dic_d[coord_]:
                    if not self.dic_d:
                        break
                    d_ = self.dic_d[coord_][dep_]
                    c_ = d_['C']
                    if c_ in self.dic_c:
                        pen.setColor(self.dic_c[c_])
                        pen.setCapStyle(Qt.FlatCap)
                        painter.setPen(pen)
                        painter.drawPoint(d_['X'], d_['Y'])

        if not self.mp_:
            self.mp_ = QPoint(int(self.width() / 2), self.height())
        if self.parent.z_ is not None and self.dic_t:
            y_ = int(self.height() * (1  - (self.parent.z_ - self.dic_t['Z_min']) / (self.dic_t['Z_max'] - self.dic_t['Z_min'])))
            pen.setColor(QColor(255, 255, 255))
            pen.setCapStyle(Qt.FlatCap)
            painter.setPen(pen)
            painter.drawLine(self.mp_.x() - 5, y_, self.mp_.x() + 5, y_)
            painter.drawText(self.mp_.x() + 15, y_, str(round(self.parent.z_, 3)))
        if self.p1 and self.p2 and self.dic_t:
            pen.setWidth(1)
            pen.setColor(QColor(255, 0, 165))
            pen.setCapStyle(Qt.FlatCap)
            painter.setPen(pen)
            yi, yf, x_yi, x_yf = [self.p1.y(), self.p2.y(), self.p1.x(), self.p2.x()] \
                if self.p1.y() < self.p2.y() else [self.p2.y(), self.p1.y(), self.p2.x(), self.p1.x()]
            yi = min(max(0, yi), self.height())
            yf = min(max(0, yf), self.height())
            x_yi = min(max(0, x_yi), self.width())
            x_yf = min(max(0, x_yf), self.width())
            painter.drawLine(x_yi, yf, x_yf, yf)
            dd = abs((x_yf - x_yi) * (self.dic_t['D_max'] - self.dic_t['D_min']) / self.width())
            painter.drawText(int((x_yi + x_yf) / 2), max(yf, self.fps), f' {round(dd, 3)}')

            pen.setColor(QColor(255, 165, 0))
            painter.setPen(pen)
            painter.drawLine(x_yi, yi, x_yi, yf)
            dz = (yf - yi) * (self.dic_t['Z_max'] - self.dic_t['Z_min']) / self.height()

            painter.setPen(pen)
            painter.drawText(min(x_yi, self.width() - self.fps * 3), max(self.fps, int((yi + yf) / 2)), f' {round(dz, 3)}')

        pen.setWidth(15)
        pen.setBrush(QColor(255, 0, 0, 100))
        pen.setCapStyle(Qt.RoundCap)
        painter.setPen(pen)
        painter.drawPoint(self.mp_)

        if self.p_track:
            pen.setWidth(5)
            pen.setStyle(Qt.DotLine)
            pen.setBrush(QColor(0, 0, 255, 90))

            painter.setPen(pen)
            painter.drawLine(self.p_track.x(), 0, self.p_track.x(), self.height())
        if self.dic_t:
            pen.setBrush(QColor(255, 255, 0))
            painter.setPen(pen)
            painter.drawText(0, 20, str(round(self.dic_t['Z_max'], 3)))
            painter.drawText(0, self.height(), str(round(self.dic_t['Z_min'], 3)))

            pen.setWidth(15)
            pen.setBrush(QColor(255, 0, 0, 100))
            painter.setPen(pen)
            z_ = self.dic_t['Z_min'] + (1 - self.mp_.y() / self.height()) * (self.dic_t['Z_max'] - self.dic_t['Z_min'])
            painter.drawText(self.mp_.x() + 15, self.mp_.y(), str(round(z_, 3)))

    def mouseReleaseEvent(self, evt_):
        if self.p1 == evt_.pos():
            if not self.dic_d:
                return
            self.mp_ = evt_.pos()
            self.x_value = (self.dic_t[f'D_min'] +
                            self.mp_.x() / self.width() * (self.dic_t[f'D_max'] - self.dic_t[f'D_min']))
            y_ = (self.dic_t['Z_min'] +
                            (1 - self.mp_.y() / self.height()) * (self.dic_t['Z_max'] - self.dic_t['Z_min']))
            if y_ < self.y_value:
                self.y_value = y_
            if not self.list_spiral:
                self.list_spiral = self.calc_spiral()
        else:
            self.p2 = evt_.pos()
        self.update()

    def mousePressEvent(self, evt_):
        if self.p2:
            self.p2 = None
        self.p1 = evt_.pos()

    def mouseMoveEvent(self, evt_):
        if not self.dic_d:
            return
        if self.p1 and evt_.buttons() != Qt.NoButton:
            self.p2 = evt_.pos()
        if 'LL' in self.dic_t:
            if 'track' not in self.dic_t:
                ll_ = self.dic_t['LL'].asPolyline()
                pt0_ = QgsPoint(ll_[0])
                pt1_ = QgsPoint(ll_[1])
                az_ = pt0_.azimuth(pt1_)
                len_l = pt0_.distance(pt1_)
                self.dic_t['track'] = {'az': az_, 'len_l': len_l}
                # self.dic_t['track'] = {'e': pt0_.x(), 'n': pt1_.x()}
                lf_ = self.dic_t['LF'].asPolyline()
                pt2_ = QgsPoint(lf_[0])
                pt3_ = QgsPoint(lf_[1])
                len_f = pt2_.distance(pt3_)
                self.dic_t['track']['len_f'] = len_f
            else:
                az_ = self.dic_t['track']['az']
                len_l = self.dic_t['track']['len_l']
                len_f = self.dic_t['track']['len_f']
            perc_1 = evt_.pos().x() / self.width()
            perc_2 = self.dic_t['D_min'] + (self.dic_t['D_max'] - self.dic_t['D_min']) * perc_1
            pt2_ = self.dic_t['LF'].interpolate(perc_2).get()
            if not pt2_:
                return
            x_ = pt2_.x()
            y_ = pt2_.y()
            az1 = math.radians(az_)
            pt3_ =  QgsPoint(x_ + len_l * math.sin(az1), y_ + len_l * math.cos(az1))
            lg_1 = QgsGeometry().fromPolyline([pt2_, pt3_])
            self.p_track = evt_.pos()
            self.parent.set_track_rb(lg_1)
        self.update()

    def mouseDoubleClickEvent(self, a0):
        self.y_value = (self.dic_t['Z_min'] +
              (1 - self.mp_.y() / self.height()) * (self.dic_t['Z_max'] - self.dic_t['Z_min']))
        # print(self.y_value)

    def reset(self):
        self.list_ = []
        self.dic_t = {}
        self.dic_d = {}
        self.x_value = 0
        self.y_value = 999999
        self.update()
    @staticmethod
    def calc_spiral(ws_=9):
        x = y = 0
        dx = 0
        dy = -1
        list_ = []
        for i in range(ws_ ** 2):
            if (-ws_ / 2 < x <= ws_ / 2) and (-ws_ / 2 < y <= ws_ / 2):
                list_.append((x, y))
            if x == y or (x < 0 and x == -y) or (x > 0 and x == 1 - y):
                dx, dy = -dy, dx
            x, y = x + dx, y + dy
        return list_

    def update_painter(self, dic_):
        self.dic_d = dic_['d']
        self.dic_c = dic_['c']
        self.update()


class CloudThread(QThread):
    sig_status = pyqtSignal(list, dict)
    # sig_error = pyqtSignal(dict)

    def __init__(self, main, parent, dic_, list_layer=None, stats=False):
        QThread.__init__(self)
        self.main = main
        self.parent = parent
        self.list_ = []
        self.stats = stats
        self.pol_ =dic_['rec']
        self.dic_ = dic_
        self.list_layer = list_layer
        self.stop = False
        self.dic_class_color = {}
        self.dic_layer_quant = {}
        self.list_pc = []

    def run(self):
        # print('run', math.degrees(self.dic_['pit']))
        # self.check_az_range()
        if self.stats:
            dens_ = 0
            for layer_ in self.list_layer:
                quant_ = 0
                prov_ = layer_.dataProvider()
                max_err = 0.0001
                p_limit = 1
                while True:
                    p_limit *= 2
                    len_ = len(prov_.identify(maxErrorInMapCoords=max_err, extentGeometry=self.pol_, pointsLimit=p_limit))
                    if len_ <= quant_:
                        break
                    quant_ = len_
                dens_ += quant_
            self.parent.le_max_dens.setText(f'{dens_:0.1f}')
            return

        area_ = self.pol_.area()
        quant_ = 1000
        press_ = 1
        list_ = []
        while press_ > 0.00001:
            quant_ *= 10
            dens_ = quant_ / area_
            press_ = (1/dens_) ** 0.5
            list_.append((press_, quant_))
        print(list_)

        for max_err, p_limit in list_:
        # for max_err, p_limit in [(0.10, 10000)]:
            dic_threshold = {
                'D0_min': 99999.0,
                'D0_max': 0.0,
                'D1_min': 99999.0,
                'D1_max': 0.0,
                'P0_min': 0.0,
                'P0_max': 0.0,
                'P1_min': 0.0,
                'P1_max': 0.0,
                'Z_min': 99999.0,
                'Z_max': -99999.0,
                'I_min': 99999,
                'I_max': -99999,
            }
            for layer_ in self.list_layer:
                prov_ = layer_.dataProvider()

                if layer_.name() not in self.dic_class_color:
                    self.dic_class_color[layer_.name()] = {}
                    for cat_ in layer_.renderer().categories():
                        if cat_.renderState():
                            self.dic_class_color[layer_.name()].update({cat_.value(): cat_.color()})
                if layer_.name() in self.dic_layer_quant and self.dic_layer_quant[layer_.name()] == 'break':
                    continue
                self.list_pc = prov_.identify(maxErrorInMapCoords=max_err, extentGeometry=self.pol_, pointsLimit=p_limit)
                print('quant_=', len(self.list_pc))
                if layer_.name() not in self.dic_layer_quant:
                    self.dic_layer_quant[layer_.name()] = len(self.list_pc)
                elif len(self.list_pc) <= self.dic_layer_quant[layer_.name()]:
                    self.dic_layer_quant[layer_.name()] = 'break'
                    print(layer_.name(), 'break', len(self.list_pc), self.dic_layer_quant[layer_.name()])
                    continue
                else:
                    self.dic_layer_quant[layer_.name()] = len(self.list_pc)

                if not self.list_pc:
                    continue
                for pc_ in self.list_pc:
                    if self.stop:
                        return
                    if pc_['Classification'] not in self.dic_class_color[layer_.name()]:
                        continue
                    p_l = QgsGeometry(QgsPoint(pc_['X'], pc_['Y']))
                    for i, ll_, lf_  in self.dic_['rll']:
                        d_n = ll_.distance(p_l)

                        pc_[f'D{i}'] = d_n
                        if d_n < dic_threshold[f'D{i}_min']:
                            dic_threshold[f'D{i}_min'] = d_n
                        elif d_n > dic_threshold[f'D{i}_max']:
                            dic_threshold[f'D{i}_max'] = d_n

                        dep_n = lf_.distance(p_l)
                        pc_[f'P{i}'] = dep_n
                        if not dic_threshold[f'P{i}_max']:
                            dic_threshold[f'P{i}_max'] = lf_.length()

                    z_n = pc_['Z']
                    if z_n < dic_threshold['Z_min']:
                        dic_threshold['Z_min'] = z_n
                    elif z_n > dic_threshold['Z_max']:
                        dic_threshold['Z_max'] = z_n

                    i_n = pc_['Intensity']
                    if i_n < dic_threshold['I_min']:
                        dic_threshold['I_min'] = i_n
                    elif i_n > dic_threshold['I_max']:
                        dic_threshold['I_max'] = i_n

                self.calc_poins(self.list_pc, dic_threshold, layer_.name())

    def calc_poins(self, list_in, dic_t, layer_):
        # print('calc_poins', 'circ=', 'circ' in self.dic_)

        list_wdl = [self.parent.wdl_prof]
        h_ = self.parent.wdl_prof.height()
        w_ = self.parent.wdl_prof.width()
        for i, wdl_ in enumerate(list_wdl):
            dic_t['D_min'] = dic_t[f'D{i}_min']
            dic_t['D_max'] = dic_t[f'D{i}_max']
            dic_t['P_min'] = dic_t[f'D{i}_min']
            dic_t['P_max'] = dic_t[f'D{i}_max']
            dic_t['LL'] = self.dic_['rll'][i][1]
            dic_t['LF'] = self.dic_['rll'][i][2]
            dic_aux = {}
            for tag_ in dic_t:
                dic_aux[tag_] = dic_t[tag_]
            wdl_.dic_t = dic_aux
            wdl_.y_value = 999999
            wdl_.mp_ = None

        dic_0 = {}

        for dic_p in list_in:
            if self.stop:
                return
            if not 'D0' in dic_p:
                continue
            y_ = int(h_ * (1  - (dic_p['Z'] - dic_t['Z_min']) / (dic_t['Z_max'] - dic_t['Z_min'])))
            x_0 = int((dic_p['D0'] - dic_t['D0_min']) * w_ / (dic_t['D0_max'] - dic_t['D0_min']))
            p_0 = dic_p['P0']
            i_ = int((dic_p['Intensity'] - dic_t['I_min']) * 255 / (dic_t['I_max'] - dic_t['I_min']))
            c_ = int(dic_p['Classification'])
            r_ = int(dic_p['Red'] / 256) if 'Red' in dic_p else 0
            g_ = int(dic_p['Green'] / 256) if 'Green' in dic_p else 0
            b_ = int(dic_p['Blue'] / 256) if 'Blue' in dic_p else 0
            e_ = round(dic_p['X'], 4)
            n_ = round(dic_p['Y'], 4)

            if f'{x_0},{y_}' not in dic_0:
                dic_0[f'{x_0},{y_}'] = {f'{p_0:.4f}':
                    {'X': x_0, 'Y': y_, 'P': p_0, 'I': i_, 'R': r_, 'G': g_, 'B': b_, 'C': c_, 'E': e_, 'N': n_}}
            else:
                dic_0[f'{x_0},{y_}'][f'{p_0:.4f}'] = \
                    {'X': x_0, 'Y': y_, 'P': p_0, 'I': i_, 'R': r_, 'G': g_, 'B': b_, 'C': c_, 'E': e_, 'N': n_}

        self.parent.wdl_prof.update_painter({'d':dic_0, 'c':self.dic_class_color[layer_]})


def calc_proj(p_, az_, d_):
    x_ = p_.x()
    y_ = p_.y()
    az1 = math.radians(az_)
    return QgsPointXY(x_ + d_ * math.sin(az1), y_ + d_ * math.cos(az1))
